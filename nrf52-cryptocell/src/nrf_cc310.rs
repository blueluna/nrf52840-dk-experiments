#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use cty;

/* automatically generated by rust-bindgen */

pub const CRYPTOCELL_ARCH_BASE_ADDRESS: u32 = 1342349312;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const SASI_INFINITE: u32 = 4294967295;
pub const SASI_SUCCESS: u32 = 0;
pub const SASI_FAIL: u32 = 1;
pub const SASI_1K_SIZE_IN_BYTES: u32 = 1024;
pub const SASI_BITS_IN_BYTE: u32 = 8;
pub const SASI_BITS_IN_32BIT_WORD: u32 = 32;
pub const SASI_OK: u32 = 0;
pub const SASI_MAX_UINT32_VAL: u32 = 4294967295;
pub const CRYS_ERROR_BASE: u32 = 15728640;
pub const CRYS_ERROR_LAYER_RANGE: u32 = 65536;
pub const CRYS_ERROR_MODULE_RANGE: u32 = 256;
pub const CRYS_LAYER_ERROR_IDX: u32 = 0;
pub const LLF_LAYER_ERROR_IDX: u32 = 1;
pub const GENERIC_ERROR_IDX: u32 = 5;
pub const AES_ERROR_IDX: u32 = 0;
pub const DES_ERROR_IDX: u32 = 1;
pub const HASH_ERROR_IDX: u32 = 2;
pub const HMAC_ERROR_IDX: u32 = 3;
pub const RSA_ERROR_IDX: u32 = 4;
pub const DH_ERROR_IDX: u32 = 5;
pub const ECPKI_ERROR_IDX: u32 = 8;
pub const RND_ERROR_IDX: u32 = 12;
pub const COMMON_ERROR_IDX: u32 = 13;
pub const KDF_ERROR_IDX: u32 = 17;
pub const HKDF_ERROR_IDX: u32 = 18;
pub const AESCCM_ERROR_IDX: u32 = 21;
pub const FIPS_ERROR_IDX: u32 = 23;
pub const PKA_MODULE_ERROR_IDX: u32 = 33;
pub const CHACHA_ERROR_IDX: u32 = 34;
pub const EC_MONT_EDW_ERROR_IDX: u32 = 35;
pub const CHACHA_POLY_ERROR_IDX: u32 = 36;
pub const POLY_ERROR_IDX: u32 = 37;
pub const SRP_ERROR_IDX: u32 = 38;
pub const CRYS_AES_MODULE_ERROR_BASE: u32 = 15728640;
pub const CRYS_DES_MODULE_ERROR_BASE: u32 = 15728896;
pub const CRYS_HASH_MODULE_ERROR_BASE: u32 = 15729152;
pub const CRYS_HMAC_MODULE_ERROR_BASE: u32 = 15729408;
pub const CRYS_RSA_MODULE_ERROR_BASE: u32 = 15729664;
pub const CRYS_DH_MODULE_ERROR_BASE: u32 = 15729920;
pub const CRYS_ECPKI_MODULE_ERROR_BASE: u32 = 15730688;
pub const LLF_ECPKI_MODULE_ERROR_BASE: u32 = 15796224;
pub const CRYS_RND_MODULE_ERROR_BASE: u32 = 15731712;
pub const LLF_RND_MODULE_ERROR_BASE: u32 = 15797248;
pub const CRYS_COMMON_MODULE_ERROR_BASE: u32 = 15731968;
pub const CRYS_KDF_MODULE_ERROR_BASE: u32 = 15732992;
pub const CRYS_HKDF_MODULE_ERROR_BASE: u32 = 15733248;
pub const CRYS_AESCCM_MODULE_ERROR_BASE: u32 = 15734016;
pub const CRYS_FIPS_MODULE_ERROR_BASE: u32 = 15734528;
pub const PKA_MODULE_ERROR_BASE: u32 = 15737088;
pub const CRYS_CHACHA_MODULE_ERROR_BASE: u32 = 15737344;
pub const CRYS_CHACHA_POLY_MODULE_ERROR_BASE: u32 = 15737856;
pub const CRYS_POLY_MODULE_ERROR_BASE: u32 = 15738112;
pub const CRYS_SRP_MODULE_ERROR_BASE: u32 = 15738368;
pub const CRYS_EC_MONT_EDW_MODULE_ERROR_BASE: u32 = 15737600;
pub const GENERIC_ERROR_BASE: u32 = 16056320;
pub const CRYS_FATAL_ERROR: u32 = 16056320;
pub const CRYS_OUT_OF_RESOURCE_ERROR: u32 = 16056321;
pub const CRYS_ILLEGAL_RESOURCE_VAL_ERROR: u32 = 16056322;
pub const CRYS_OK: u32 = 0;
pub const CRYS_AESCCM_INVALID_USER_CONTEXT_POINTER_ERROR: u32 = 15734016;
pub const CRYS_AESCCM_ILLEGAL_KEY_SIZE_ERROR: u32 = 15734017;
pub const CRYS_AESCCM_INVALID_KEY_POINTER_ERROR: u32 = 15734018;
pub const CRYS_AESCCM_INVALID_ENCRYPT_MODE_ERROR: u32 = 15734019;
pub const CRYS_AESCCM_USER_CONTEXT_CORRUPTED_ERROR: u32 = 15734020;
pub const CRYS_AESCCM_DATA_IN_POINTER_INVALID_ERROR: u32 = 15734021;
pub const CRYS_AESCCM_DATA_OUT_POINTER_INVALID_ERROR: u32 = 15734022;
pub const CRYS_AESCCM_DATA_IN_SIZE_ILLEGAL: u32 = 15734023;
pub const CRYS_AESCCM_DATA_OUT_DATA_IN_OVERLAP_ERROR: u32 = 15734024;
pub const CRYS_AESCCM_DATA_OUT_SIZE_INVALID_ERROR: u32 = 15734025;
pub const CRYS_AESCCM_ADDITIONAL_BLOCK_NOT_PERMITTED_ERROR: u32 = 15734026;
pub const CRYS_AESCCM_ILLEGAL_DMA_BUFF_TYPE_ERROR: u32 = 15734027;
pub const CRYS_AESCCM_ILLEGAL_PARAMETER_SIZE_ERROR: u32 = 15734028;
pub const CRYS_AESCCM_ILLEGAL_PARAMETER_PTR_ERROR: u32 = 15734029;
pub const CRYS_AESCCM_ILLEGAL_DATA_TYPE_ERROR: u32 = 15734030;
pub const CRYS_AESCCM_CCM_MAC_INVALID_ERROR: u32 = 15734031;
pub const CRYS_AESCCM_LAST_BLOCK_NOT_PERMITTED_ERROR: u32 = 15734032;
pub const CRYS_AESCCM_ILLEGAL_PARAMETER_ERROR: u32 = 15734033;
pub const CRYS_AESCCM_NOT_ALL_ADATA_WAS_PROCESSED_ERROR: u32 = 15734035;
pub const CRYS_AESCCM_NOT_ALL_DATA_WAS_PROCESSED_ERROR: u32 = 15734036;
pub const CRYS_AESCCM_ADATA_WAS_PROCESSED_ERROR: u32 = 15734037;
pub const CRYS_AESCCM_ILLEGAL_NONCE_SIZE_ERROR: u32 = 15734038;
pub const CRYS_AESCCM_ILLEGAL_TAG_SIZE_ERROR: u32 = 15734039;
pub const CRYS_AESCCM_CTX_SIZES_ERROR: u32 = 15734056;
pub const CRYS_AESCCM_ILLEGAL_PARAMS_ERROR: u32 = 15734057;
pub const CRYS_AESCCM_IS_NOT_SUPPORTED: u32 = 15734271;
pub const SASI_FATAL_ERROR: u32 = 16056320;
pub const SASI_OUT_OF_RESOURCE_ERROR: u32 = 16056321;
pub const SASI_ILLEGAL_RESOURCE_VAL_ERROR: u32 = 16056322;
pub const SASI_AES_INVALID_USER_CONTEXT_POINTER_ERROR: u32 = 15728640;
pub const SASI_AES_INVALID_IV_OR_TWEAK_PTR_ERROR: u32 = 15728641;
pub const SASI_AES_ILLEGAL_OPERATION_MODE_ERROR: u32 = 15728642;
pub const SASI_AES_ILLEGAL_KEY_SIZE_ERROR: u32 = 15728643;
pub const SASI_AES_INVALID_KEY_POINTER_ERROR: u32 = 15728644;
pub const SASI_AES_KEY_TYPE_NOT_SUPPORTED_ERROR: u32 = 15728645;
pub const SASI_AES_INVALID_ENCRYPT_MODE_ERROR: u32 = 15728646;
pub const SASI_AES_USER_CONTEXT_CORRUPTED_ERROR: u32 = 15728647;
pub const SASI_AES_DATA_IN_POINTER_INVALID_ERROR: u32 = 15728648;
pub const SASI_AES_DATA_OUT_POINTER_INVALID_ERROR: u32 = 15728649;
pub const SASI_AES_DATA_IN_SIZE_ILLEGAL: u32 = 15728650;
pub const SASI_AES_DATA_OUT_DATA_IN_OVERLAP_ERROR: u32 = 15728651;
pub const SASI_AES_DATA_IN_BUFFER_SIZE_ERROR: u32 = 15728652;
pub const SASI_AES_DATA_OUT_BUFFER_SIZE_ERROR: u32 = 15728653;
pub const SASI_AES_ILLEGAL_PADDING_TYPE_ERROR: u32 = 15728654;
pub const SASI_AES_INCORRECT_PADDING_ERROR: u32 = 15728655;
pub const SASI_AES_CORRUPTED_OUTPUT_ERROR: u32 = 15728656;
pub const SASI_AES_DATA_OUT_SIZE_POINTER_INVALID_ERROR: u32 = 15728657;
pub const SASI_AES_DECRYPTION_NOT_ALLOWED_ON_THIS_MODE: u32 = 15728658;
pub const SASI_AES_ADDITIONAL_BLOCK_NOT_PERMITTED_ERROR: u32 = 15728661;
pub const SASI_AES_CTX_SIZES_ERROR: u32 = 15728662;
pub const SASI_AES_ILLEGAL_PARAMS_ERROR: u32 = 15728736;
pub const SASI_AES_CTR_ILLEGAL_BLOCK_OFFSET_ERROR: u32 = 15728752;
pub const SASI_AES_CTR_ILLEGAL_COUNTER_ERROR: u32 = 15728753;
pub const SASI_AES_IS_NOT_SUPPORTED: u32 = 15728895;
pub const SASI_AES_USER_CTX_SIZE_IN_WORDS: u32 = 19;
pub const SASI_AES_BLOCK_SIZE_IN_WORDS: u32 = 4;
pub const SASI_AES_IV_SIZE_IN_WORDS: u32 = 4;
pub const SASI_AES_KEY_MAX_SIZE_IN_WORDS: u32 = 4;
pub const CRYS_AESCCM_USER_CTX_SIZE_IN_WORDS: u32 = 38;
pub const CRYS_AESCCM_KEY_SIZE_WORDS: u32 = 8;
pub const CRYS_AESCCM_NONCE_MIN_SIZE_BYTES: u32 = 7;
pub const CRYS_AESCCM_NONCE_MAX_SIZE_BYTES: u32 = 13;
pub const CRYS_AESCCM_MAC_MIN_SIZE_BYTES: u32 = 4;
pub const CRYS_AESCCM_MAC_MAX_SIZE_BYTES: u32 = 16;
pub const CRYS_AESCCM_STAR_NONCE_SIZE_BYTES: u32 = 13;
pub const CRYS_AESCCM_STAR_SOURCE_ADDRESS_SIZE_BYTES: u32 = 8;
pub const CRYS_AESCCM_MODE_CCM: u32 = 0;
pub const CRYS_AESCCM_MODE_STAR: u32 = 1;
pub const CRYS_RND_MAX_RESEED_COUNTER: u32 = 4294967280;
pub const CRYS_RND_MAX_GEN_VECTOR_SIZE_BITS: u32 = 524287;
pub const CRYS_RND_MAX_GEN_VECTOR_SIZE_BYTES: u32 = 65535;
pub const CRYS_RND_AES_BLOCK_SIZE_IN_WORDS: u32 = 4;
pub const CRYS_RND_SEED_MAX_SIZE_WORDS: u32 = 12;
pub const CRYS_RND_ADDITINAL_INPUT_MAX_SIZE_WORDS: u32 = 12;
pub const CRYS_RND_AES_KEY_128_SIZE_WORDS: u32 = 4;
pub const CRYS_RND_AES_KEY_192_SIZE_WORDS: u32 = 6;
pub const CRYS_RND_AES_KEY_256_SIZE_WORDS: u32 = 8;
pub const CRYS_RND_WORK_BUFFER_SIZE_WORDS: u32 = 1528;
pub const CRYS_RND_TRNG_SRC_INNER_OFFSET_WORDS: u32 = 2;
pub const CRYS_PRNG_FIPS_KAT_OUT_DATA_SIZE: u32 = 64;
pub const DX_VERSION_PRODUCT_BIT_SHIFT: u32 = 24;
pub const DX_VERSION_PRODUCT_BIT_SIZE: u32 = 8;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type SaSiVirtAddr_t = usize;
pub type SaSiBool_t = u32;
pub type SaSiStatus = u32;
#[doc = " Boolean false definition."]
pub const SaSiBool_SASI_FALSE: SaSiBool = 0;
#[doc = " Boolean true definition."]
pub const SaSiBool_SASI_TRUE: SaSiBool = 1;
#[doc = " Boolean definition."]
pub type SaSiBool = u32;
#[doc = " The typedef definition of all of the error codes that are returned from the CRYS functions"]
pub type CRYSError_t = u32;
#[doc = " Encrypt operation."]
pub const SaSiAesEncryptMode_t_SASI_AES_ENCRYPT: SaSiAesEncryptMode_t = 0;
#[doc = " Decrypt operation."]
pub const SaSiAesEncryptMode_t_SASI_AES_DECRYPT: SaSiAesEncryptMode_t = 1;
#[doc = " Maximal number of operations."]
pub const SaSiAesEncryptMode_t_SASI_AES_NUM_OF_ENCRYPT_MODES: SaSiAesEncryptMode_t = 2;
#[doc = " Reserved."]
pub const SaSiAesEncryptMode_t_SASI_AES_ENCRYPT_MODE_LAST: SaSiAesEncryptMode_t = 2147483647;
#[doc = "Encrypt or Decrypt operation mode."]
pub type SaSiAesEncryptMode_t = u32;
#[doc = "< ECB mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_ECB: SaSiAesOperationMode_t = 0;
#[doc = "< CBC mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_CBC: SaSiAesOperationMode_t = 1;
#[doc = "< CBC-MAC mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_CBC_MAC: SaSiAesOperationMode_t = 2;
#[doc = "< CTR mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_CTR: SaSiAesOperationMode_t = 3;
#[doc = "< XCBC-MAC mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_XCBC_MAC: SaSiAesOperationMode_t = 4;
#[doc = "< CMAC mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_CMAC: SaSiAesOperationMode_t = 5;
#[doc = "< XTS mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_XTS: SaSiAesOperationMode_t = 6;
#[doc = "< CBC-CTS mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_CBC_CTS: SaSiAesOperationMode_t = 7;
#[doc = "< OFB mode."]
pub const SaSiAesOperationMode_t_SASI_AES_MODE_OFB: SaSiAesOperationMode_t = 8;
#[doc = " Maximal number of AES modes"]
pub const SaSiAesOperationMode_t_SASI_AES_NUM_OF_OPERATION_MODES: SaSiAesOperationMode_t = 9;
#[doc = " Reserved."]
pub const SaSiAesOperationMode_t_SASI_AES_OPERATION_MODE_LAST: SaSiAesOperationMode_t = 2147483647;
#[doc = "AES operation mode."]
pub type SaSiAesOperationMode_t = u32;
#[doc = "< No padding."]
pub const SaSiAesPaddingType_t_SASI_AES_PADDING_NONE: SaSiAesPaddingType_t = 0;
#[doc = "< PKCS7 padding."]
pub const SaSiAesPaddingType_t_SASI_AES_PADDING_PKCS7: SaSiAesPaddingType_t = 1;
#[doc = " Maximal number of AES padding modes"]
pub const SaSiAesPaddingType_t_SASI_AES_NUM_OF_PADDING_TYPES: SaSiAesPaddingType_t = 2;
#[doc = " Reserved."]
pub const SaSiAesPaddingType_t_SASI_AES_PADDING_TYPE_LAST: SaSiAesPaddingType_t = 2147483647;
#[doc = "AES padding type."]
pub type SaSiAesPaddingType_t = u32;
#[doc = "< user key."]
pub const SaSiAesKeyType_t_SASI_AES_USER_KEY: SaSiAesKeyType_t = 0;
#[doc = "< Kplt hardware key."]
pub const SaSiAesKeyType_t_SASI_AES_PLATFORM_KEY: SaSiAesKeyType_t = 1;
#[doc = "< Kcst hardware key."]
pub const SaSiAesKeyType_t_SASI_AES_CUSTOMER_KEY: SaSiAesKeyType_t = 2;
#[doc = " Maximal number of AES key types"]
pub const SaSiAesKeyType_t_SASI_AES_NUM_OF_KEY_TYPES: SaSiAesKeyType_t = 3;
#[doc = " Reserved."]
pub const SaSiAesKeyType_t_SASI_AES_KEY_TYPE_LAST: SaSiAesKeyType_t = 2147483647;
#[doc = "AES key type."]
pub type SaSiAesKeyType_t = u32;
#[doc = " Defines the IV buffer  - 16 bytes array."]
pub type SaSiAesIv_t = [u8; 16usize];
#[doc = " Defines the AES key data buffer."]
pub type SaSiAesKeyBuffer_t = [u8; 16usize];
#[doc = " The user's context prototype - the argument type that is passed by the user"]
#[doc = "to the AES APIs. The context saves the state of the operation and must be saved by the user"]
#[doc = "till the end of the APIs flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SaSiAesUserContext_t {
    #[doc = " Context buffer for internal usage."]
    pub buff: [u32; 19usize],
}
#[test]
fn bindgen_test_layout_SaSiAesUserContext_t() {
    assert_eq!(
        ::core::mem::size_of::<SaSiAesUserContext_t>(),
        76usize,
        concat!("Size of: ", stringify!(SaSiAesUserContext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<SaSiAesUserContext_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SaSiAesUserContext_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SaSiAesUserContext_t>())).buff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SaSiAesUserContext_t),
            "::",
            stringify!(buff)
        )
    );
}
#[doc = " AES User Key Data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SaSiAesUserKeyData_t {
    #[doc = "< Pointer to the key."]
    pub pKey: *mut u8,
    #[doc = "< The key size in bytes. Valid values:"]
    #[doc = "<ul><li> For XTS mode - 32 or 64 byte, indicating the full size of the double key (2x128 or 2x256 bit).</li>"]
    #[doc = "<li>For XCBC-MAC mode - 16 byte (limited by the standard).</li>"]
    #[doc = "<li>For all other modes - 16, 24 or 32 byte.</li></ul>"]
    pub keySize: usize,
}
#[test]
fn bindgen_test_layout_SaSiAesUserKeyData_t() {
    assert_eq!(
        ::core::mem::size_of::<SaSiAesUserKeyData_t>(),
        16usize,
        concat!("Size of: ", stringify!(SaSiAesUserKeyData_t))
    );
    assert_eq!(
        ::core::mem::align_of::<SaSiAesUserKeyData_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SaSiAesUserKeyData_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SaSiAesUserKeyData_t>())).pKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SaSiAesUserKeyData_t),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SaSiAesUserKeyData_t>())).keySize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SaSiAesUserKeyData_t),
            "::",
            stringify!(keySize)
        )
    );
}
#[doc = " AES HW Key Data - this structure is likely to be changed when we'll start using it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SaSiAesHwKeyData_t {
    #[doc = "< Slot number."]
    pub slotNumber: usize,
}
#[test]
fn bindgen_test_layout_SaSiAesHwKeyData_t() {
    assert_eq!(
        ::core::mem::size_of::<SaSiAesHwKeyData_t>(),
        8usize,
        concat!("Size of: ", stringify!(SaSiAesHwKeyData_t))
    );
    assert_eq!(
        ::core::mem::align_of::<SaSiAesHwKeyData_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SaSiAesHwKeyData_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SaSiAesHwKeyData_t>())).slotNumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SaSiAesHwKeyData_t),
            "::",
            stringify!(slotNumber)
        )
    );
}
extern "C" {
    #[doc = "@brief This function is used to initialize an AES operation context."]
    #[doc = "To operate the AES machine, this must be the first API called."]
    #[doc = ""]
    #[doc = "@return SASI_OK on success,"]
    #[doc = "@return A non-zero value from ssi_aes_error.h on failure."]
    pub fn SaSi_AesInit(
        pContext: *mut SaSiAesUserContext_t,
        encryptDecryptFlag: SaSiAesEncryptMode_t,
        operationMode: SaSiAesOperationMode_t,
        paddingType: SaSiAesPaddingType_t,
    ) -> SaSiStatus;
}
extern "C" {
    #[doc = "@brief This function sets the key information for the AES operation, in the context that was initialized by SaSi_AesInit."]
    #[doc = "\\note When FIPS certification mode is set to ON, and the mode is AES-XTS, weak keys are not allowed (128/256 lsb bits must be"]
    #[doc = "different than 128/256 msb bits, according to the key size)."]
    #[doc = "@return SASI_OK on success,"]
    #[doc = "@return A non-zero value from ssi_aes_error.h on failure."]
    pub fn SaSi_AesSetKey(
        pContext: *mut SaSiAesUserContext_t,
        keyType: SaSiAesKeyType_t,
        pKeyData: *mut cty::c_void,
        keyDataSize: usize,
    ) -> SaSiStatus;
}
extern "C" {
    #[doc = "@brief This function sets the IV, counter or tweak data for the following AES operation on the same context."]
    #[doc = "The context must be first initialized by SaSi_AesInit."]
    #[doc = "It must be called at least once prior to the first SaSi_AesBlock operation on the same context - for those ciphers that require it."]
    #[doc = "If needed, it can also be called to override the IV in the middle of a sequence of SaSi_AesBlock operations."]
    #[doc = ""]
    #[doc = "@return SASI_OK on success,"]
    #[doc = "@return A non-zero value from ssi_aes_error.h on failure."]
    pub fn SaSi_AesSetIv(pContext: *mut SaSiAesUserContext_t, pIV: *mut u8) -> SaSiStatus;
}
extern "C" {
    #[doc = "@brief This function retrieves the current IV, counter or tweak from the AES context."]
    #[doc = ""]
    #[doc = "@return SASI_OK on success,"]
    #[doc = "@return A non-zero value from ssi_aes_error.h on failure."]
    pub fn SaSi_AesGetIv(pContext: *mut SaSiAesUserContext_t, pIV: *mut u8) -> SaSiStatus;
}
extern "C" {
    #[doc = "@brief This function performs an AES operation on an input data buffer, according to the configuration defined in the context parameter."]
    #[doc = "It can be called as many times as needed, until all the input data is processed."]
    #[doc = "SaSi_AesInit, SaSi_AesSetKey, and for some ciphers SaSi_AesSetIv, must be called before"]
    #[doc = "the first call to this API with the same context."]
    #[doc = ""]
    #[doc = "@return SASI_OK on success,"]
    #[doc = "@return A non-zero value from ssi_aes_error.h on failure."]
    pub fn SaSi_AesBlock(
        pContext: *mut SaSiAesUserContext_t,
        pDataIn: *mut u8,
        dataInSize: usize,
        pDataOut: *mut u8,
    ) -> SaSiStatus;
}
extern "C" {
    #[doc = "@brief This function is used to finish AES operation."]
    #[doc = ""]
    #[doc = "It processes the last data block if needed, finalizes the AES operation (cipher-specific),"]
    #[doc = "and produces operation results (for MAC operations)."]
    #[doc = "\\note In case AES padding is used (PKCS#7) Din and Dout user's buffers must include extra space for"]
    #[doc = "the padding scheme."]
    #[doc = ""]
    #[doc = "@return SASI_OK on success,"]
    #[doc = "@return A non-zero value from ssi_aes_error.h on failure."]
    pub fn SaSi_AesFinish(
        pContext: *mut SaSiAesUserContext_t,
        dataSize: usize,
        pDataIn: *mut u8,
        dataInBuffSize: usize,
        pDataOut: *mut u8,
        dataOutBuffSize: *mut usize,
    ) -> SaSiStatus;
}
extern "C" {
    #[doc = "@brief This function releases and crears resources after AES operations."]
    #[doc = ""]
    #[doc = "@return SASI_OK on success,"]
    #[doc = "@return A non-zero value from ssi_aes_error.h on failure."]
    pub fn SaSi_AesFree(pContext: *mut SaSiAesUserContext_t) -> SaSiStatus;
}
#[doc = " Key size 128 bits."]
pub const CRYS_AESCCM_KeySize_t_CRYS_AES_Key128BitSize: CRYS_AESCCM_KeySize_t = 0;
#[doc = " Key size 192 bits."]
pub const CRYS_AESCCM_KeySize_t_CRYS_AES_Key192BitSize: CRYS_AESCCM_KeySize_t = 1;
#[doc = " Key size 256 bits."]
pub const CRYS_AESCCM_KeySize_t_CRYS_AES_Key256BitSize: CRYS_AESCCM_KeySize_t = 2;
#[doc = " Key size 512 bits."]
pub const CRYS_AESCCM_KeySize_t_CRYS_AES_Key512BitSize: CRYS_AESCCM_KeySize_t = 3;
#[doc = " Number of optional key sizes."]
pub const CRYS_AESCCM_KeySize_t_CRYS_AES_KeySizeNumOfOptions: CRYS_AESCCM_KeySize_t = 4;
#[doc = " Reserved."]
pub const CRYS_AESCCM_KeySize_t_CRYS_AES_KeySizeLast: CRYS_AESCCM_KeySize_t = 2147483647;
#[doc = " Typedefs  ****************************/"]
pub type CRYS_AESCCM_KeySize_t = u32;
#[doc = " AES_CCM key buffer definition."]
pub type CRYS_AESCCM_Key_t = [u8; 32usize];
#[doc = " AES_CCM MAC buffer definition."]
pub type CRYS_AESCCM_Mac_Res_t = [u8; 16usize];
#[doc = " AES_CCM_STAR source address buffer defintion."]
pub type CRYS_AESCCMStar_SourceAddress_t = [u8; 8usize];
#[doc = " AES_CCM_STAR Nonce buffer defintion."]
pub type CRYS_AESCCMStar_Nonce_t = [u8; 13usize];
#[doc = " Context Structure  ***********************/"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRYS_AESCCM_UserContext_t {
    #[doc = " AES CCM context buffer for internal usage."]
    pub buff: [u32; 38usize],
}
#[test]
fn bindgen_test_layout_CRYS_AESCCM_UserContext_t() {
    assert_eq!(
        ::core::mem::size_of::<CRYS_AESCCM_UserContext_t>(),
        152usize,
        concat!("Size of: ", stringify!(CRYS_AESCCM_UserContext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYS_AESCCM_UserContext_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYS_AESCCM_UserContext_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYS_AESCCM_UserContext_t>())).buff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_AESCCM_UserContext_t),
            "::",
            stringify!(buff)
        )
    );
}
extern "C" {
    #[doc = "@brief This function initializes the AES CCM context."]
    #[doc = ""]
    #[doc = "It formats of the input data, calculates AES-MAC value for the formatted B0 block containing control information and"]
    #[doc = "CCM unique value (Nonce), and initializes the AES context structure including the initial CTR0 value."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value on failure as defined crys_aesccm_error.h."]
    pub fn CC_AESCCM_Init(
        ContextID_ptr: *mut CRYS_AESCCM_UserContext_t,
        EncrDecrMode: SaSiAesEncryptMode_t,
        CCM_Key: *mut u8,
        KeySizeId: CRYS_AESCCM_KeySize_t,
        AdataSize: u32,
        TextSizeQ: u32,
        N_ptr: *mut u8,
        SizeOfN: u8,
        SizeOfT: u8,
        ccmMode: u32,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief This function receives a CCM context and a block of additional data, and adds it to the AES MAC"]
    #[doc = "calculation."]
    #[doc = "This API can be called only once per operation context. It should not be called in case AdataSize was set to"]
    #[doc = "zero in ::CC_AESCCM_Init."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value on failure as defined crys_aesccm_error.h."]
    pub fn CRYS_AESCCM_BlockAdata(
        ContextID_ptr: *mut CRYS_AESCCM_UserContext_t,
        DataIn_ptr: *mut u8,
        DataInSize: u32,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief This function can be invoked for any block of Text data whose size is a multiple of 16 bytes,"]
    #[doc = "excluding the last block that must be processed by ::CRYS_AESCCM_Finish."]
    #[doc = "<ul><li> If encrypting:"]
    #[doc = "Continues calculation of the intermediate AES_MAC value of the text data, while simultaneously encrypting the text data using AES_CTR,"]
    #[doc = "starting from CTR value = CTR0+1.</li>"]
    #[doc = "<li>If decrypting:"]
    #[doc = "Continues decryption of the text data, while calculating the intermediate AES_MAC value of decrypted data.</li></ul>"]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value on failure as defined crys_aesccm_error.h."]
    pub fn CRYS_AESCCM_BlockTextData(
        ContextID_ptr: *mut CRYS_AESCCM_UserContext_t,
        DataIn_ptr: *mut u8,
        DataInSize: u32,
        DataOut_ptr: *mut u8,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief This function must be the last to be called on the text data."]
    #[doc = "It can either be called on the entire text data (if transferred as one block), or on the last block of the text data,"]
    #[doc = "even if total size of text data is equal to 0."]
    #[doc = "It performs the same operations as ::CRYS_AESCCM_BlockTextData, but additionally:"]
    #[doc = "<ul><li> If encrypting: </li>"]
    #[doc = "<ul><li>If the size of text data is not in multiples of 16 bytes, it pads the remaining bytes with zeros to a full 16-bytes block and"]
    #[doc = "processes the data using AES_MAC and AES_CTR algorithms.</li>"]
    #[doc = "<li> Encrypts the AES_MAC result with AES_CTR using the CTR0 value saved in the context and places the SizeOfT bytes of MAC (tag)"]
    #[doc = "at the end.</li></ul></ul>"]
    #[doc = "<ul><li> If decrypting: </li>"]
    #[doc = "<ul><li>Processes the text data, except for the last SizeOfT bytes (tag), using AES_CTR and then AES_MAC algorithms.</li>"]
    #[doc = "<li>Encrypts the calculated MAC using AES_CTR based on the saved CTR0 value, and compares it with SizeOfT last bytes of input data (i.e."]
    #[doc = "tag value).</li>"]
    #[doc = "<li>The function saves the validation result (Valid/Invalid) in the context.</li>"]
    #[doc = "<li>Returns (as the error code) the final CCM-MAC verification result.</li></ul></ul>"]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value on failure as defined crys_aesccm_error.h."]
    pub fn CRYS_AESCCM_Finish(
        ContextID_ptr: *mut CRYS_AESCCM_UserContext_t,
        DataIn_ptr: *mut u8,
        DataInSize: u32,
        DataOut_ptr: *mut u8,
        MacRes: *mut u8,
        SizeOfT: *mut u8,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief AES CCM combines Counter mode encryption with CBC-MAC authentication."]
    #[doc = "Input to CCM includes the following elements:"]
    #[doc = "<ul><li> Payload - text data that is both authenticated and encrypted.</li>"]
    #[doc = "<li> Associated data (Adata) - data that is authenticated but not encrypted, e.g., a header.</li>"]
    #[doc = "<li> Nonce - A unique value that is assigned to the payload and the associated data.</li></ul>"]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value on failure as defined crys_aesccm_error.h."]
    pub fn CC_AESCCM(
        EncrDecrMode: SaSiAesEncryptMode_t,
        CCM_Key: *mut u8,
        KeySizeId: CRYS_AESCCM_KeySize_t,
        N_ptr: *mut u8,
        SizeOfN: u8,
        ADataIn_ptr: *mut u8,
        ADataInSize: u32,
        TextDataIn_ptr: *mut u8,
        TextDataInSize: u32,
        TextDataOut_ptr: *mut u8,
        SizeOfT: u8,
        Mac_Res: *mut u8,
        ccmMode: u32,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief This function receives the MAC source address, the frame counter and the MAC size"]
    #[doc = "and returns the required nonce for AES-CCM* as defined in ieee-802.15.4."]
    #[doc = "This API should be called before CRYS_AESCCMStar and CRYS_AESCCMStar_Init,"]
    #[doc = "and the generated nonce should be provided to these functions."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value on failure as defined crys_aesccm_error.h."]
    pub fn CRYS_AESCCMStar_NonceGenerate(
        srcAddr: *mut u8,
        FrameCounter: u32,
        SizeOfT: u8,
        nonce: *mut u8,
    ) -> CRYSError_t;
}
#[doc = " A definition for RAM buffer to be internally used in instantiation (or reseeding) operation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRYS_RND_WorkBuff_t {
    #[doc = " Internal buffer"]
    pub crysRndWorkBuff: [u32; 1528usize],
}
#[test]
fn bindgen_test_layout_CRYS_RND_WorkBuff_t() {
    assert_eq!(
        ::core::mem::size_of::<CRYS_RND_WorkBuff_t>(),
        6112usize,
        concat!("Size of: ", stringify!(CRYS_RND_WorkBuff_t))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYS_RND_WorkBuff_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYS_RND_WorkBuff_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_WorkBuff_t>())).crysRndWorkBuff as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_WorkBuff_t),
            "::",
            stringify!(crysRndWorkBuff)
        )
    );
}
#[doc = " SW entropy estimation mode."]
pub const CRYS_RND_mode_t_CRYS_RND_Fast: CRYS_RND_mode_t = 0;
#[doc = " Full entropy mode."]
pub const CRYS_RND_mode_t_CRYS_RND_Slow: CRYS_RND_mode_t = 1;
#[doc = " Reserved."]
pub const CRYS_RND_mode_t_CRYS_RND_ModeLast: CRYS_RND_mode_t = 2147483647;
#[doc = " Definition of random operation modes."]
pub type CRYS_RND_mode_t = u32;
#[doc = " RND state structure. Includes internal data that needs to be saved between boots by the user."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYS_RND_State_t {
    #[doc = " Random Seed buffer"]
    pub Seed: [u32; 12usize],
    #[doc = " Previous random data (used for continuous test)."]
    pub PreviousRandValue: [u32; 4usize],
    #[doc = " Previous additional input buffer."]
    pub PreviousAdditionalInput: [u32; 17usize],
    #[doc = " Additional input buffer."]
    pub AdditionalInput: [u32; 16usize],
    #[doc = " Additional input size in words."]
    pub AddInputSizeWords: u32,
    #[doc = " Entropy source size in words"]
    pub EntropySourceSizeWords: u32,
    #[doc = " Reseed counter (32 bits active) - indicates number of requests for entropy"]
    #[doc = "since instantiation or reseeding"]
    pub ReseedCounter: u32,
    #[doc = " Key size: 4 or 8 words according to security strength 128 bits or 256 bits"]
    pub KeySizeWords: u32,
    #[doc = " State flag used internally in the code."]
    pub StateFlag: u32,
    #[doc = " TRNG process state used internally in the code"]
    pub TrngProcesState: u32,
    #[doc = " Validation tag used internally in the code"]
    pub ValidTag: u32,
    #[doc = " Rnd source entropy size in bits"]
    pub EntropySizeBits: u32,
}
#[test]
fn bindgen_test_layout_CRYS_RND_State_t() {
    assert_eq!(
        ::core::mem::size_of::<CRYS_RND_State_t>(),
        228usize,
        concat!("Size of: ", stringify!(CRYS_RND_State_t))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYS_RND_State_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYS_RND_State_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYS_RND_State_t>())).Seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(Seed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_State_t>())).PreviousRandValue as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(PreviousRandValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_State_t>())).PreviousAdditionalInput as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(PreviousAdditionalInput)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_State_t>())).AdditionalInput as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(AdditionalInput)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_State_t>())).AddInputSizeWords as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(AddInputSizeWords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_State_t>())).EntropySourceSizeWords as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(EntropySourceSizeWords)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYS_RND_State_t>())).ReseedCounter as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(ReseedCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYS_RND_State_t>())).KeySizeWords as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(KeySizeWords)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYS_RND_State_t>())).StateFlag as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(StateFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_State_t>())).TrngProcesState as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(TrngProcesState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CRYS_RND_State_t>())).ValidTag as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(ValidTag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_RND_State_t>())).EntropySizeBits as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_RND_State_t),
            "::",
            stringify!(EntropySizeBits)
        )
    );
}
#[doc = " The RND Generate vector function pointer type definition."]
#[doc = "The prototype intendent for External and CRYS internal RND functions"]
#[doc = "pointers definitions."]
#[doc = "Full description can be found in ::CRYS_RND_GenerateVector function API."]
pub type SaSiRndGenerateVectWorkFunc_t = ::core::option::Option<
    unsafe extern "C" fn(
        rndState_ptr: *mut cty::c_void,
        outSizeBytes: u16,
        out_ptr: *mut u8,
    ) -> u32,
>;
#[doc = " Data structure required for internal FIPS verification for PRNG KAT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRYS_PrngFipsKatCtx_t {
    #[doc = " Internal working buffer."]
    pub rndWorkBuff: CRYS_RND_WorkBuff_t,
    #[doc = " Output buffer."]
    pub rndOutputBuff: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_CRYS_PrngFipsKatCtx_t() {
    assert_eq!(
        ::core::mem::size_of::<CRYS_PrngFipsKatCtx_t>(),
        6176usize,
        concat!("Size of: ", stringify!(CRYS_PrngFipsKatCtx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYS_PrngFipsKatCtx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYS_PrngFipsKatCtx_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_PrngFipsKatCtx_t>())).rndWorkBuff as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_PrngFipsKatCtx_t),
            "::",
            stringify!(rndWorkBuff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<CRYS_PrngFipsKatCtx_t>())).rndOutputBuff as *const _ as usize
        },
        6112usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYS_PrngFipsKatCtx_t),
            "::",
            stringify!(rndOutputBuff)
        )
    );
}
extern "C" {
    #[doc = "@brief This function needs to be called once."]
    #[doc = "It calls CRYS_RND_Instantiation to initialize the TRNG and the primary RND context."]
    #[doc = "An initialized RND context is required for calling RND APIs and asymmetric cryptography key generation and signatures."]
    #[doc = "The primary context returned by this function can be used as a single global context for all RND needs."]
    #[doc = "Alternatively, other contexts may be initialized and used with a more limited scope (for specific applications or specific threads)."]
    #[doc = ""]
    #[doc = "\\note The Mutexes, if used, are initialized by this API. Therefore, unlike the other APIs in the library,"]
    #[doc = "this API is not thread-safe."]
    #[doc = ""]
    #[doc = "@param[in/out] rnd_ctx - Pointer to the RND state structure."]
    #[doc = "@param[in/out] rndWorkBuff_ptr  - Pointer to the RND scratch buffer."]
    pub fn CRYS_RndInit(
        rnd_ctx: *mut cty::c_void,
        rndWorkBuff_ptr: *mut CRYS_RND_WorkBuff_t,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief This function initializes the RND context."]
    #[doc = "It must be called at least once prior to using this context with any API that requires it as a parameter (e.g., other RND APIs, asymmetric"]
    #[doc = "cryptography key generation and signatures)."]
    #[doc = "It is called as part of ARM TrustZone CryptoCell library initialization, which initializes and returns the primary RND context."]
    #[doc = "This primary context can be used as a single global context for all RND needs."]
    #[doc = "Alternatively, other contexts may be initialized and used with a more limited scope (for specific applications or specific threads)."]
    #[doc = "The call to this function must be followed by a call to ::CRYS_RND_SetGenerateVectorFunc API to set the generate vector function."]
    #[doc = "It implements referenced standard [SP800-90] - 10.2.1.3.2 - CTR-DRBG Instantiate algorithm using AES (FIPS-PUB 197) and Derivation Function (DF)."]
    #[doc = "\\note Additional data can be mixed with the random seed (personalization data or nonce). If required, this data should be provided by calling ::CRYS_RND_AddAdditionalInput prior to using this API."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_Instantiation(
        rndState_ptr: *mut cty::c_void,
        rndWorkBuff_ptr: *mut CRYS_RND_WorkBuff_t,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief Clears existing RNG instantiation state."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_UnInstantiation(rndState_ptr: *mut cty::c_void) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief This function is used for reseeding the RNG with additional entropy and additional user-provided input."]
    #[doc = "(additional data should be provided by calling ::CRYS_RND_AddAdditionalInput prior to using this API)."]
    #[doc = "It implements referenced standard [SP800-90] - 10.2.1.4.2 - CTR-DRBG Reseeding algorithm, using AES (FIPS-PUB 197) and Derivation Function (DF)."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_Reseeding(
        rndState_ptr: *mut cty::c_void,
        rndWorkBuff_ptr: *mut CRYS_RND_WorkBuff_t,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief Generates a random vector according to the algorithm defined in referenced standard [SP800-90] - 10.2.1.5.2 - CTR-DRBG."]
    #[doc = "The generation algorithm uses AES (FIPS-PUB 197) and Derivation Function (DF)."]
    #[doc = ""]
    #[doc = "\\note"]
    #[doc = "<ul id=\"noteb\"><li> The RND module must be instantiated prior to invocation of this API.</li>"]
    #[doc = "<li> In the following cases, Reseeding operation must be performed prior to vector generation:</li>"]
    #[doc = "<ul><li> Prediction resistance is required.</li>"]
    #[doc = "<li> The function returns CRYS_RND_RESEED_COUNTER_OVERFLOW_ERROR, stating that the Reseed Counter has passed its upper-limit (2^32-2).</li></ul></ul>"]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_GenerateVector(
        rndState_ptr: *mut cty::c_void,
        outSizeBytes: u16,
        out_ptr: *mut u8,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief Generates a random vector with specific limitations by testing candidates (described and used in FIPS 186-4: B.1.2, B.4.2 etc.)."]
    #[doc = ""]
    #[doc = "This function draws a random vector, compare it to the range limits, and if within range - return it in rndVect_ptr."]
    #[doc = "If outside the range, the function continues retrying until a conforming vector is found, or the maximal retries limit is exceeded."]
    #[doc = "If maxVect_ptr is provided, rndSizeInBits specifies its size, and the output vector must conform to the range [1 < rndVect < maxVect]."]
    #[doc = "If maxVect_ptr is NULL, rndSizeInBits specifies the exact required vector size, and the output vector must be the exact same"]
    #[doc = "bit size (with its most significant bit = 1)."]
    #[doc = "\\note"]
    #[doc = "The RND module must be instantiated prior to invocation of this API."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_GenerateVectorInRange(
        rndState_ptr: *mut cty::c_void,
        rndGenerateVectFunc: SaSiRndGenerateVectWorkFunc_t,
        rndSizeInBits: u32,
        maxVect_ptr: *mut u8,
        rndVect_ptr: *mut u8,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief Used for adding additional input/personalization data provided by the user,"]
    #[doc = "to be later used by the ::CRYS_RND_Instantiation/::CRYS_RND_Reseeding/::CRYS_RND_GenerateVector functions."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_AddAdditionalInput(
        rndState_ptr: *mut cty::c_void,
        additonalInput_ptr: *mut u8,
        additonalInputSize: u16,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief The CRYS_RND_EnterKatMode function sets KAT mode bit into StateFlag of global CRYS_RND_WorkingState structure."]
    #[doc = ""]
    #[doc = "The user must call this function before calling functions performing KAT tests."]
    #[doc = ""]
    #[doc = "\\note Total size of entropy and nonce must be not great than 126 words (maximal size of entropy and nonce)."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_EnterKatMode(
        rndState_ptr: *mut cty::c_void,
        entrData_ptr: *mut u8,
        entrSize: u32,
        nonce_ptr: *mut u8,
        nonceSize: u32,
        workBuff_ptr: *mut CRYS_RND_WorkBuff_t,
    ) -> CRYSError_t;
}
extern "C" {
    #[doc = "@brief The CRYS_RND_DisableKatMode function disables KAT mode bit into StateFlag of global CRYS_RND_State_t structure."]
    #[doc = ""]
    #[doc = "The user must call this function after KAT tests before actual using RND module (Instantiation etc.)."]
    #[doc = ""]
    #[doc = "@return CRYS_OK on success."]
    #[doc = "@return A non-zero value from crys_rnd_error.h on failure."]
    pub fn CRYS_RND_DisableKatMode(rndState_ptr: *mut cty::c_void);
}
#[doc = "< Success defintion."]
pub const SA_SilibRetCode_t_SA_SILIB_RET_OK: SA_SilibRetCode_t = 0;
#[doc = "< Illegal context pointer."]
pub const SA_SilibRetCode_t_SA_SILIB_RET_EINVAL_CTX_PTR: SA_SilibRetCode_t = 1;
#[doc = "< Illegal work buffer pointer."]
pub const SA_SilibRetCode_t_SA_SILIB_RET_EINVAL_WORK_BUF_PTR: SA_SilibRetCode_t = 2;
#[doc = "< Error returned from HAL layer."]
pub const SA_SilibRetCode_t_SA_SILIB_RET_HAL: SA_SilibRetCode_t = 3;
#[doc = "< Error returned from PAL layer."]
pub const SA_SilibRetCode_t_SA_SILIB_RET_PAL: SA_SilibRetCode_t = 4;
#[doc = "< Invalid HW version."]
pub const SA_SilibRetCode_t_SA_SILIB_RET_EINVAL_HW_VERSION: SA_SilibRetCode_t = 5;
#[doc = "< Invalid HW signature."]
pub const SA_SilibRetCode_t_SA_SILIB_RET_EINVAL_HW_SIGNATURE: SA_SilibRetCode_t = 6;
#[doc = "< Reserved."]
pub const SA_SilibRetCode_t_SA_SILIB_RESERVE32B: SA_SilibRetCode_t = 2147483647;
#[doc = " Definitions for error returns from SaSi_LibInit or SaSi_LibFini functions."]
pub type SA_SilibRetCode_t = u32;
extern "C" {
    #[doc = "@brief This function Perform global initialization of the ARM CryptoCell 3xx runtime library;"]
    #[doc = "it must be called once per ARM CryptoCell for 3xx cold boot cycle."]
    #[doc = ""]
    #[doc = "\\note The Mutexes, if used, are initialized by this API. Therefore, unlike the other APIs in the library,"]
    #[doc = "this API is not thread-safe."]
    #[doc = "@return SA_SILIB_RET_OK on success."]
    #[doc = "@return A non-zero value in case of failure."]
    pub fn SaSi_LibInit() -> SA_SilibRetCode_t;
}
extern "C" {
    #[doc = "@brief This function finalize the library operations. It frees the associated resources (mutexes) and call hal and pal terminate functions."]
    #[doc = "in case of active instansiation - one must call CRYS_RND_UnInstantiation to clean the rnd state."]
    pub fn SaSi_LibFini();
}
